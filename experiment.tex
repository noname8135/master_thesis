\chapter{Implementation and Evaluation}
\label{Implementation_and_Evaluation}
In this chapter, we evaluate the methods presented in Chapter 3. First, the environment and the reason of using them will be explained. Then, we will show different experiments and their corresponding results.

\section{General setup}
Table~~\ref{table:Experiment_table} is a summary of all the tools and their versions in the evaluation. We use Mininet to simulate the data center network \cite{Mininet}. It allows us to creates a large-scale virtual network easily. It provides Python APIs as well as a command line interface to customize the network. It also offers an interactive interface to test the connectivity and performance.

\begin{table}[H]
\centering
\caption{Experimental environment summary}
\begin{tabular}{|l|p{4cm}|p{4.5cm}}
\hline Item & Detail version \\
\hline
\hline Operating system & Ubuntu 14.04 x86\_64 \\
\hline Controller & Ryu\_manager 4.0 \\
\hline Network Emulator & Mininet 2.2.1 \\
\hline Topology generator & Fast Network Simulation Setup (FNSS) 0.6.1\\
\hline Packet Generator & Ryu packet library API \\
\hline Southbound API & OpenFlow 1.3 \\
\hline Virtual switch & OpenvSwitch 2.5.0 \\
\hline 
\end{tabular}
\label{table:Experiment_table}
\end{table}

To evaluate the effectiveness of the detection method under various scenarios, there will be XXXX network topologies in the evaluation. They are generated by Fast Network Simulation Setup (FNSS), a Python module able to generate various types of network topology. It not only supports DCN topologies, but also provides the Mininet API, making it extremely easy to import the generated topology into Mininet. The network topologies we use are two-tier topology, three-tier topology and fat-tree topology of various sizes. The details including number of switches and average degree (i.e. the number of links between two switches) are shown in Table~~\ref{table:network_env}. The numbers in the topology name are parameters such as number of core switches, aggregation switches or edge switches, which characterize the network size. These parameters have the same meaning as the ones in \cite{FNSS}.

\begin{table}[H]
\centering
\caption{Details of network topologies}
\begin{tabular}{|l||l|l|l|}
\hline topology type & number of switches & average degree \\
\hline
\hline fat\_tree\_2 & 5 & 2 \\
\hline fat\_tree\_4 & 20 & 4 \\
\hline fat\_tree\_6 & 45 & 6 \\
\hline fat\_tree\_8 & 80 & 8 \\
\hline fat\_tree\_10 & 125 & 10 \\
\hline fat\_tree\_12 & 180 & 12 \\
\hline fat\_tree\_14 & 245 & 14 \\
\hline two\_tier\_2\_3 & 5 & 3 \\
\hline two\_tier\_3\_4 & 7 & 4 \\
\hline two\_tier\_4\_4 & 8 & 4.5 \\
\hline two\_tier\_5\_4 & 9 & 4.8 \\
\hline two\_tier\_6\_8 & 14 & 7.42 \\
\hline two\_tier\_6\_14 & 20 & 9.1 \\
\hline two\_tier\_8\_10 & 18 & 9.4 \\
\hline two\_tier\_10\_10 & 20 & 10.5 \\
\hline two\_tier\_12\_8 & 20 & 10 \\
\hline two\_tier\_12\_12 & 24 & 12.5 \\
\hline two\_tier\_14\_6 & 20 & 8.7 \\
\hline two\_tier\_16\_18 & 34 & 17.47 \\
\hline 
\hline three\_tier\_2\_3\_3 & 14 & 2.79 \\
\hline three\_tier\_3\_4\_5 & 27 & 3.11 \\
\hline three\_tier\_4\_4\_4 & 24 & 3.33 \\
\hline three\_tier\_4\_3\_2 & 13 & 3.23 \\
\hline three\_tier\_6\_6\_6 & 48 & 3.75 \\
\hline 
\end{tabular}
\label{table:network_env}
\end{table}

The in-band control is used for control channel. It is the default setting of Mininet and is more convenient to set up. Although there are special flow entries for in-band control channel, they are hidden and will not have any influence on our experiment. Only one controller is used. The hosts are irrelevant to our method, only a minimal number of them are in our network environment to make the topology reasonable. In fat tree topology, the number of hosts is the number of pods divided by 2, while in two-tier and three-tier topology, one host is connected to each edge switches. There are 254 flow tables in an OpenFlow switch simulated by Mininet. The flow entries are installed pro-actively in the OpenFlow switches, and due to the reason stated in the last paragraph of Section~\ref{Further_discussion}, the controller will maintain a record of switches, including ports, links and flow entries. 

The core algorithm of the flow entry detection method is implemented as a Ryu controller application. It obtains essential information from the configuration files, find aggregated groups, generate raw packets and send them by \texttt{Packet\_out}, and check \texttt{Packet\_in} to see if the packets come back as expected. Packets are generated by Ryu's built-in API library. In order to send \texttt{Packet\_out} with a raw packet, the action should be set to ``forwarding to \texttt{OFPP\_TABLE}'', which means the packet is sent to the first flow table after the action is executed; otherwise, \texttt{Packet\_out} will not be processed as an ordinary packet, and the action set will be executed directly without going through the processing pipeline \cite{PACKETOUT}. Due to the reason stated in the last paragraph of Section~\ref{Further_discussion}, the detection packets from the controller should be sent to a normal port rather than the default controller-specifying port \texttt{OFPP\_CONTROLLER}. 

\section{Flow entry generation}
We choose common protocol fields and properly set dependency fields such as ether type, IP protocol type. The chosen fields in the field set are those that will be in our experimental network environment. The chosen set is listed as follows:

\begin{itemize}
\item
ethernet layer: eth\_dst, eth\_src
\item
ip layer: ipv4\_src, ipv4\_dst
\item
tcp/udp/icmp layer: tcp\_src, tcp\_dst, udp\_src, udp\_dst, icmpv4\_type, icmpv4\_code
\end{itemize}

The flow entries are randomly generated, and the Ryu application installs them on the switches. When a flow entry is generated, the script selects a random match field from the set of chosen match fields along with random values in a valid range and format, and selects the output port and the switch on which this entry is randomly. Due to the reason stated in Section~\ref{Further_discussion}, there will be only ``output port\_no'' action in all the flow entries. To make the scenario more realistic, the following setup is considered for flow entry generation:

\begin{itemize}
\item 
The cookie field is used as an identifier for every entry in our implementation. It is a unique integer from 0 to total entry number minus one.\sout{\red{Why mentioning cookie?}}
\item
Since the two entries with same priority that is possible to match the same packet will cause undefined behavior \cite{OF_SPEC}, the priority of entries on the same switch are different \red{Is it sufficient to set the entries with the same entries to different priorities?}.
\item
There will be duplicate field and value set deliberately generated with a 20\% chance. It is quite reasonable to have duplicates on different switches. 
\item
The IP is restricted to a /24 subnet.
\item
The number of flow entries on each switch highly depends on the forwarding policy \cite{MPFHMRSV09}. For simplicity, the number of entries on every switch is the same. 
\item
According to a firewall log found on the Internet \cite{PORT_FREQ}, the occurrence frequency of TCP ports are distributed in the following percentages to make it close to real case:
\begin{itemize}
\item
port 80: 50\%
\item
port 443: 25\%
\item
other common ports (7,20,21,22,23,25,43,53,109,110,156,161,194,546,547): 15\%
\item
other ports in 1024: 10\%
\end{itemize}
\end{itemize}

\section{Experiment and result}
In this section, we will compare the effectiveness of our method under different types of network environments. Each subsection contains different experiment designed for different purposes. The control variables including topology type, network scale, and number of flow entries will be experimented and discussed. 

In statistic tables in following subsections, the effective aggregation rate is the number that the total number of entries in the network divided by total number of groups, and the actual aggregation rate is the total number of entries inside aggregated groups divided by total number of groups, both of them do not include the auxiliary entries. Due to the fact that entries that has other entries with same match field and value may belong to more than one aggregated group, the total entries in groups will be more than the total entries exist in the network. 

When an auxiliary entry is installed, a short period of waiting time is needed, otherwise after the Packet\_Out is send, there is a low chance that it might be forwarded unexpectedly. This happens when it arrives at an certain switch that contains an auxiliary entry, the entry is not installed. Therefore, for every installation of auxiliary entry, the controller will wait 0.01 second before continuing the process to ensure the auxiliary entries work as expected. The time for adding auxiliary flow entries is included in execution time.

\subsection{Influence of topology type}
In order to see the influence of topology type, we select 8 different topologies with the same number of 20 switches from Table~~\ref{table:network_env} with 20 entries on each switch. The topologies involved are listed along with their experimental result in Table~~\ref{table:different_topo_type}. 

\begin{table}
\centering
\caption{Influence of different topology types}
\begin{tabular}{|l||l|l|l|l|}
\hline topology name & Effective aggregation rate & Actual aggregation rate & Execution time(sec) & Number of auxiliary entry \\
\hline
\hline fat\_tree\_4 & 2.96 & 3.27 & 8.27 & 142 \\
\hline two\_tier\_6\_14 & 1.77 & 1.82 & 6.69 & 262 \\ 
\hline two\_tier\_10\_10 & 2.70 & 3.04 & 7.96 & 182 \\
\hline two\_tier\_14\_6 & 2.72 & 3.81 & 9.57 & 109 \\ 
\hline three\_tier\_2\_3\_5 & 1.44 & 1.49 & 6.23 & 290 \\
\hline three\_tier\_4\_2\_7 & 1.35 & 1.56 & 6.61 & 271 \\
\hline three\_tier\_4\_4\_3 & 1.83 & 2.03 & 7.72 & 232 \\
\hline three\_tier\_5\_5\_2 & 2.21 & 2.51 & 7.63 & 184 \\
\hline
\end{tabular}
\label{table:different_topo_type}
\end{table}


From the result in Table~~\ref{table:different_topo_type} and Figure~\ref{different_topo_bar}, we can clearly see that although the number of switches are the same, the way how they are connected to each other leads to significant differences. 
Ideally, the more switch a switch is connected to, the higher the chance that we can extend a group more, making it contains more entries. However, XXXXXXXXXXXXXXXX, .
And in the 4 three\_tier topologies, the aggregation rates drop as the number of auxiliary entry increases.

\begin{figure}[H]
\begin{center} 
\includegraphics[width=1.4\linewidth]{figures/exp_topotype_bar.png}
\end{center}
\caption{The bar chart of different topologies.}
\label{different_topo_bar}
\end{figure}



We select the most effective one, fat\_tree\_4, and the least effective one, three\_tier\_4\_2\_7, for further examination with the distribution of the number of entry contained in each group, shown as Figure~\ref{different_topo_distribute}. From the figure, we can see two things: first, a lot of groups in three\_tier\_2\_7 only contain one entry. XXXXXXXXXXXXXXXXXXXXX
Second, the area coverage of three\_tier\_4\_2\_7 is apparently larger than fat\_tree\_4. This can mean that the groups contain either a lot more auxiliary entries or redundant entries caused by the entries with same match field an value, or even both. 

In order for further inspection, XXXXXXXXXXXX.
\begin{figure}[H]
\begin{center} 
\includegraphics[width=1.4\linewidth]{figures/exp_topotype_distribute.png}
\end{center}
\caption{The comparison between .}
\label{different_topo_distribute}
\end{figure}

\subsection{Influence of network scale}
To observe how effective our method is under different network scales, different size of fat tree topology will be used. Since the network scale grows significantly with higher pod number(the only parameter fat tree topologies have), we will only have from fat\_tree\_2 to fat\_tree\_14. There are also 20 entries on each switch.

The result is in Table~~\ref{table:different_scale}

\begin{table}
\centering
\caption{Influence of different network scales}
\begin{tabular}{|l||l|l|l|l|}
\hline topology name & Effective aggregation rate & Actual aggregation rate & Execution time(sec) & Number of auxiliary entry \\
\hline
\hline fat\_tree\_2 & 2.70 & 2.84 & 1.26 & 35 \\
\hline fat\_tree\_4 & 2.96 & 3.27 & 8.27 & 142 \\
\hline fat\_tree\_6 & 2.85 & 3.27 & 19.16 & 327 \\
\hline fat\_tree\_8 & 2.81 & 3.29 & 33.03 & 589 \\
\hline fat\_tree\_10 & 2.91 & 3.37 & 51.81 & 921 \\
\hline fat\_tree\_12 & 2.89 & 3.36 & 74.78 & 1334 \\
\hline fat\_tree\_14 & 2.79 & 3.29 & 102.56 & 1800 \\
\hline
\end{tabular}
\label{table:different_scale}
\end{table}

As we can see from the trend chart of effective aggregation rate and actual aggregation rate in Figure~\ref{different_scale_rate_trend}, XXXXXXXXXXX.

\begin{figure}[H]
\begin{center} 
\includegraphics[width=1\textwidth]{figures/exp_scale_rate_trend.png}
\end{center}
\caption{The trend chart of aggregation rates under different scale of network.}
\label{different_scale_rate_trend}
\end{figure}



The trend of execution time and number of auxiliary entries while increasing the network scale are shown as Figure~\ref{different_scale_time_trend} and Figure~\ref{different_scale_aux_trend}. 


Since an auxiliary entry is needed for every entry leads to a host, and the , the number of the auxiliary entries 
XXXXXXXXXX.


\begin{figure}[H]
\begin{center} 
\includegraphics[width=1\textwidth]{figures/exp_scale_time_trend.png}
\end{center}
\caption{The trend chart of execution time under different scale of network.}
\label{different_scale_time_trend}
\end{figure}



\begin{figure}[H]
\begin{center} 
\includegraphics[width=1\textwidth]{figures/exp_scale_time_trend.png}
\end{center}
\caption{The trend chart of number of auxiliary entries under different scale of network.}
\label{different_scale_aux_trend}
\end{figure}



\subsection{Influence of flow entry number}
In this experiment, we will use only one topology - fat\_tree\_4 and change the number of entries on each switch to see the influence it might bring. The number of entries on each switch are from 5 to 50, with 5 entries increasing every run. The result table is in Table~~\ref{table:different_entry_per_switch}. The execution time and the number of auxiliary grow linearly, which is quite expected since the number of entry also grows linearly.

\begin{table}
\centering
\caption{Different number of entries in a switch.}
\begin{tabular}{|l||l|l|l|l|}
\hline Number of entries per switch & Effective aggregation rate & Actual aggregation rate & Execution time (sec) & Number of auxiliary entry \\
\hline
\hline 5 & 2.27 & 2.66 & 1.64 & 36 \\
\hline 10 & 2.38 & 2.82 & 3.98 & 72 \\
\hline 15 & 2.59 & 2.91 & 5.53 & 110 \\
\hline 20 & 2.96 & 3.27 & 8.27 & 142 \\
\hline 25 & 2.94 & 3.29 & 11.08 & 179 \\
\hline 30 & 3.14 & 3.55 & 15.03 & 214 \\
\hline 35 & 3.19 & 3.58 & 17.22 & 242 \\
\hline 40 & 3.36 & 3.72 & 19.24 & 280 \\
\hline 45 & 3.37 & 3.80 & 24.42 & 310 \\
\hline 50 & 3.45 & 3.86 & 26.19 & 346 \\
\hline
\end{tabular}
\label{table:different_entry_per_switch}
\end{table}

The trend chart Figure~\ref{exp_entrynum_trend} shows that XXXXXXXXXXXXXX. 

\begin{figure}[H]
\begin{center} 
\includegraphics[width=1\textwidth]{figures/exp_entrynum_trend.png}
\end{center}
\caption{The trend chart of different number of entries on every switch.}
\label{exp_entrynum_trend}
\end{figure}

\subsection{Sum up for experimental results}
-------------------------
However, the aggregation rates do not always grow along with the scale of the network. The reason is that XXXXXXXXXXXXX.


The degree of switch is particularly to our method because the higher the degree is, the higher the chance of finding more entries in an aggregated group will be.


factors that influence the result:
	-link number
	-the number of host/edge switch
	-scatter 
	-overlapping same (f,v) set

%host number = k^3 / 4