\chapter{Detection Method Implementation and Evaluation}
In this chapter, we evaluate the methods presented in Chapter 3. First, the environment and the reason of using them will be explained. Then, we will show test items and their corresponding results.

\section{Environmental setup}
Table~~\ref{table:Experiment_table} is a summary of all the tools and their versions in the evaluation. We use Mininet to simulate the data center network \cite{Mininet}. It allows us to creates a large-scale virtual network easily. It provides python API as well as command line interface to customize the network. It also offers an interactive interface to test the connectivity and performance.

\begin{table}[H]
\centering
\caption{Experimental environment summary}
\begin{tabular}{|l|p{4cm}|p{4.5cm}}
\hline Item & Detail version \\
\hline Operating system & Ubuntu 14.04 x86\_64 \\
\hline Controller & Ryu\_manager 4.0 \\
\hline Network Emulator & Mininet 2.2.1 \\
\hline Topology generator & Fast Network Simulation Setup (FNSS) 0.6.1\\
\hline Packet Generator & Ryu packet library API \\
\hline Southbound API & OpenFlow 1.3 \\
\hline Virtual switch & OpenvSwitch 2.5.0 \\
\hline 
\end{tabular}
\label{table:Experiment_table}
\end{table}

To evaluate the effectiveness of the detection method under different environment, there will be XXXX different network topologies in our experiment, they are generated by Fast Network Simulation Setup, known as FNSS, which is a python module that is able to generate plenty types of network topology for experiment. It not only supports datacenter network topologies, which is suitable for our background assumption, but also provides Mininet API, making it extremely easy to import the generated topology into Mininet. The netwrok topologies we use are two-tier topology, three-tier topology and fat tree topology, there will be multiple size of each of them. The detail of each is shown as Table~~\ref{table:network_env}.

\begin{table}[H]
\centering
\caption{Detailed of network topologies}
\begin{tabular}{|l|p{4cm}|p{4.5cm}|p{4.5cm}|}
\hline  topology type & number of switch & number of link & number of flow entry in each switch \\
\hline fat tree topology & 123 & 456 & 789	\\
\hline two-tier topology & 123 & 456 & 789	\\
\hline three-tier topology & 123 & 456 & 789	\\
\hline 
\end{tabular}
\label{table:network_env}
\end{table}


The in-band control is used for control channel. It is the default setting of Mininet and is more convenient to set up. Although there will be special flow entries in-band control channel, they are hidden and will not have any influence on our experiment. Hosts are irrelevant in our methods, there will not be any host in our environment, and one controller is used. Some setup like topology or number of switches are different in two parts of our work, they will be described individually.

There are 254 flow tables in OpenFlow switch simulated by Mininet, we will only use the first table. In order to simulate the flow entries exist in the OpenFlow switches in the network, the flow entry are installed pro-actively, and due to the reason stated in the last paragraph of Section~\ref{Further_discussion}, the controller will maintain a record of switches, including ports, links and flow entries. 

The field set can be customized according to our requirement. We choose the fields that are more common and avoid the dependency field such as ether type, IP protocol type. Just like what is mentioned in the third paragraph of Section~\ref{SDN and OpenFlow}, although we intend to keep the match fields simple and have only one match field and one match value for each flow entry, the flow entries should still have additional dependent match fields. The chosen field set of out experiment is list as follow:
\begin{enumerate}
\item
ethernet layer: eth\_dst, eth\_src
\item
ip layer: ipv4\_src, ipv4\_dst, 
\item
tcp/udp/icmp layer: tcp\_src, tcp\_dst, udp\_src, udp\_dst, icmpv4\_type, icmpv4\_code
\end{enumerate}

The Ryu application will randomly generate number of flow entries and install them on switches. The number of entries on each switch is decided according to its tier type: XXXXXXXXXXXXXXXXXXXXXXXXXXXXX.
When a flow entry is generated, the script selects a match field from the set of chosen match fields along with random value in valid range and format, output port and the switch this entry is going to install on. Due to the reason stated in Section~\ref{Further_discussion}, there will be only ``output port\_no'' action in all the flow entries.

\section{Method implementation} 
There are two modules in our program: The first module consist of Mininet API and FNSS API. It will generate network topology and flow entries, and save the related information into a configure file. The core algorithm of flow entry detection method is implemented in the second module as a Ryu controller application. It obtains essential information from the configure files, find aggregated groups, generate raw packets and send them by Packet\_Out, and check Packet\_in to see if the packets come back as expected. Packets are generated by Ryu's built-in API library. The Packet\_Out will not be processed as normal traffic packet. The action set will be executed directly \cite{PACKETOUT}. In order to send PACKET\_OUT with raw packet and let it go through the processing pipe line of a switch, the action should be set ``forwarding to OFPP\_TABLE'', which means after the action is executed, the packet is sent to the first flow table, and the rest of the process goes on as usual. Due to the reason stated in the last paragraph of \ref{Further_discussion}, the detection packets from the controller should be sent to a normal port other than the default controller-specifying port OFPP\_CONTROLLER. 

\section{}

\section{Evaluation}

\subsection{Estimated expectation}
XXXXXXXXXX put big O analysis here XXXXXXXXXXXXXXX
