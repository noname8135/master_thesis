\chapter{Flow entry verification and Fake link detection}
This paper try to propose detection method for the scenario that a switch is compromised. Since, the situation that a host is compromised or owned by a malicious user is more common and has already been widely discussed, this work try to solve some problems a compromised switch might bring. The possibilities of how attacks happen has already been discussed in \ref{SDN security}. As a defender, we will be focusing on detection methods of certain scenarios. There are two parts in our work. First, we will define the threat model both parts share. Then both part will be explained along with their attack scenarios and detection algorithm separately.

\section{Threat model}
The attacks take place in a SDN network. The following assumptions is used as threat model:
\begin{enumerate}
\item
Only one controller is used.
\item
The switches implement OpenFlow with version later than 1.0 as Southbound protocol.
\item
The switches is able to access the Internet. 
\item
Only one OpenFlow switch is compromised. No cooperation for attack will happen between multiple entities inside SDN network.
\item
Other parts of the network such as controller, other switches and hosts function normally. Any potential flaw is unintentional and is out of our scope.
\item
An attacker cannot totally change the way of switch processing or core mechanism. He can only perform attack by manipulating some elements.
\item
Initially, the network is all clean, nothing has been compromised. The attacks take place some time after the whole network is established. 
\end{enumerate}

\section{Flow entry verification}
In the first part of our work, we propose a method that is able to detect if the flow entries work as expected. The method is inspired by \cite{CKGL15}. There are mainly two enhancement in our work: First, our method reduce the needed packet number and therefore increase the efficiency significantly. Second, the additional flow entries we need to install is less than the original method, resulting in lower cost for setting up and cleaning up. 

\subsection{Attack scenario}
\label{flow_entry_verification_attack_scenario}
Assume an attacker is able to add, remove, or modify the entries in the flow tables of the compromised
switch without notifying the controller. He can forward packets to the place it should not go. Other action is beyond our detection scope, so there will be only \textit{output to port} actions among all the flow entries of all the switches in our experimental environment.

\subsection{Detection method}
\label{Detection_method}
The main idea of the method is to assemble a packet that will go through a series of switches by matching the match fields in the flow entries of those switches. Then the packet will be sent into the network, and should be sent back to the controller if nothing goes wrong. In order to achieve such goal, we take advantage of network-wise visibility provided by the controller. The flowchart of the flow entry detection process in the controller is shown as Figure~\ref{flow_entry_detection_flowchart}. 

\begin{figure}[H]
\begin{center} 
\includegraphics[width=1\textwidth]{figures/flow_entry_detection_flowchart.png}
\end{center}
\caption{The flowchart of flow entry detection process.}
\label{flow_entry_detection_flowchart}
\end{figure}

First, we have to define the \textit{aggregated groups}. An aggregated group consists of one or more than one flow entries existing in the switches. Each of those flow entry have output action pointing to the next OpenFlow switch which contains a flow entry that is also in the same aggregated group. The flow entries in the same aggregated group must satisfy either of the two conditions, we will name them \textit{aggregation condition} for later usage: 
\begin{enumerate}
\item
There is at least one other flow entry that has exactly the same match field and same value in a different switch.
\item
There is no other flow entry with the same match field.
\end{enumerate}

With the complete view of network provided by controller and aggregation condition prepared, one is able to construct a special packet that will be sent from the first flow entry all the way down to the last flow entry in the same aggregated group, and finally come back to the controller, indicating that all the flow entries inside this aggregate group work as expected. 

Figure~\ref{aggregated_group} illustrates an aggregated group and the content of a constructed packet. The flow entries connected by arrows belong to the same group. After determining an aggregated group, the controller constructs a packet according to the match fields of flow entries inside the aggregated group. With the aggregation condition, it will match every flow entry inside the aggregated group. In the example figure, we have a controller, three switches, which are S1,S2 and S3, and a packet waiting to be constructed. In S1, there is a flow entry that contains match field eth\_dst, match value A and output action to S2. In S2, the flow entry has match field ipv4\_src, match value B and output action to S3. Initially in S3, there is no flow entry that matches the aggregation condition of this aggregated group, so we use it as the ending node and set a flow entry with arbitrary match field (in the example, arp\_op is used) and value C in order to notify the controller. According to these match fields, the constructed packet will contain eth\_dst as A, ipv4\_src as B and arp\_op as C. Then the packet is sent to S1, and will match to the flow entry and be sent to S2. After this, the packet will match the second flow entry in the aggregated group and be sent to S3. Finally, when it reaches the last flow entry made by us, it will be sent back to the controller, and the processing of this aggregated group is done. 

\begin{figure}[H]
\begin{center} 
\includegraphics[width=1\textwidth]{figures/aggregated_group.png}
\end{center}
\caption{An aggregated group and constructed packet.}
\label{aggregated_group}
\end{figure}

The process of generating a packet is done along with defining one aggregated group, the pseudo-code of it is as follow:

\begin{algorithm}[htb]
  \caption{Packet generating process.}
  
  \begin{algorithmic}[1]
    \Require
      Information of all switches, $switches$;
      Global visited status of every flow entry, $visited$;
    \Ensure
      Details of flow entries are obtainable from switches;

    \Function{flow\_entry\_traversal}{switches}
      \ForAll{$switch$ in $switches$}
        \ForAll{$entry$ in $switch$}
          \State Extract $match\_field$, $match\_value$, $action$ from $entry$;
          \State $entry\_id$ = $switch$ + $match\_field$ + $match\_value$;
          \If{NOT $visited$[$entry\_id$]}
            \State $visited$[$entry\_id$] = true
            \Call{check_aggregation_condition}{}
            \EndIf
            \State \Call{packet\_gen}{$match\_field$, $match\_value$, $action$, empty};
          \EndIf
      \EndFor
        \EndFor
    \EndFunction

    \Function{packet\_gen}{match\_field$, match\_value$, action$, packet$}      
      \State Extract $next\_switch$ from $action$;

      \ForAll {$entry$ in $next\_switch$}
        \State Extract $match\_field$, $match\_value$, $action$ from $entry$;
        \State $entry\_id$ = $switch$ + $match\_field$ + $match\_value$;
        \If{NOT $visited$[$entry\_id$]}   
          
        \EndIf
      \EndFor
      \State \Return $packet$ 
    \EndFunction
  \end{algorithmic}

  \If{$packet$[$match\_field$] is set and $packet$[$match\_field$] = $match\_value$}            
    \State $visited$[$entry\_id$] = true;
  \ElsIf{$packet$[$match\_field$] is not set}
    \State $visited$[$entry\_id$] = true;
    \State $packet$[$match\_field$] = $match\_value$;
\end{algorithm}

When defining an aggregated group, we start with an unvisited flow entry, seek for a flow entry that matches the aggregation condition, and go to the next flow entry in other switch according to the output action recursively. Eventually, switch that does not have any entry that matches the aggregation condition for this group is reached, the aggregated group defining process ends, and a packet will be generated in correspondent to the flow entries inside the aggregated group. By looping through all the flow entries inside the switches, we should be able to cover all of the flow entries with multiple aggregated group. After all of the flow entries with output action is visited and belong to certain aggregated groups, and all the flow entries will be verified after sending the same number of packets with the number of aggregated groups. Other actions such as drop, set field, change TTL etc. will be ignored because they are not in our scope. 

\section{Fake link detection}

-----
When a switch is compromised, an attacker is surely able to drop LLDP and causes DOS. However, it is very noticeable. We will focus on the MITM types of attack
-----
\subsection{Attack scenario}
\subsection{Detection method}


-----------------------------------------------------------
control-channel hijacking \cite{AAS14}. 

Compromised switches not only have the same capabilities as the malicious hosts, but they are also capable of performing more dynamic and severe attacks.
First, a compromised switch can be used for traffic eavesdropping. Both data and control traffic passing through the compromised switch can be replicated and sent to the attacker for further processing. Furthermore, the attacker can interfere with the control traffic passing through the compromised
switches to perform man-in-the-middle attacks [8]. By doing so, the
attacker can act as the controller to some target switches. The attacker can
also spoof control messages to the controller on behalf of the target

Below is our attack scenario assumption: 
- The control channel is properly protected with TLS protocol, meaning
that it provides confidentiality for the control traffic as well as mutual
authentication between the controller and switches.

Packet pair

- The dispersion in normal vs attack scenario, regardless of congestion

----
If this is not the case, further narrow down process is needed to find the location of the compromised switch XXXXXXXXXXXXXXXXXXXXXXX.
----

Time and space complexity


Packet forwarded to non-existent ports are just dropped

\begin{algorithm}[htb]
  \caption{ Framework of ensemble learning for our system.}
  \label{alg:Framwork}
  \begin{algorithmic}[1]
    \Require
      The set of positive samples for current batch, $P_n$;
      The set of unlabelled samples for current batch, $U_n$;
      Ensemble of classifiers on former batches, $E_{n-1}$;
    \Ensure
      Ensemble of classifiers on the current batch, $E_n$;
    \State Extracting the set of reliable negative and/or positive samples $T_n$ from $U_n$ with help of $P_n$;
    \label{code:fram:extract}
    \State Training ensemble of classifiers $E$ on $T_n \cup P_n$, with help of data in former batches;
    \label{code:fram:trainbase}
    \State $E_n=E_{n-1}cup E$;
    \label{code:fram:add}
    \State Classifying samples in $U_n-T_n$ by $E_n$;
    \label{code:fram:classify}
    \State Deleting some weak classifiers in $E_n$ so as to keep the capacity of $E_n$;
    \label{code:fram:select} \\
    \Return $E_n$;
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
  \caption{An example for format For \& While Loop in Algorithm}
  \begin{algorithmic}[1]
    \For{each $i\in [1,9]$}
      \State initialize a tree $T_{i}$ with only a leaf (the root);
      \State $T=T\cup T_{i};$
    \EndFor
    \ForAll {$c$ such that $c\in RecentMBatch(E_{n-1})$}
      \label{code:TrainBase:getc}
      \State $T=T\cup PosSample(c)$;
      \label{code:TrainBase:pos}
    \EndFor;
    \For{$i=1$; $i<n$; $i++$ }
      \State $//$ Your source here;
    \EndFor
    \For{$i=1$ to $n$}
      \State $//$ Your source here;
    \EndFor
    \State $//$ Reusing recent base classifiers.
    \label{code:recentStart}
    \While {$(|E_n| \leq L_1 )and( D \neq \phi)$}
      \State Selecting the most recent classifier $c_i$ from $D$;
      \State $D=D-c_i$;
      \State $E_n=E_n+c_i$;
    \EndWhile
    \label{code:recentEnd}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
  \caption{Conjugate Gradient Algorithm with Dynamic Step-Size Control}
  \label{alg::conjugateGradient}
  \begin{algorithmic}[1]
    \Require
      $f(x)$: objective funtion;
      $x_0$: initial solution;
      $s$: step size;
    \Ensure
      optimal $x^{*}$
    \State initial $g_0=0$ and $d_0=0$;
    \Repeat
      \State compute gradient directions $g_k=\bigtriangledown f(x_k)$;
      \State compute Polak-Ribiere parameter $\beta_k=\frac{g_k^{T}(g_k-g_{k-1})}{\parallel g_{k-1} \parallel^{2}}$;
      \State compute the conjugate directions $d_k=-g_k+\beta_k d_{k-1}$;
      \State compute the step size $\alpha_k=s/\parallel d_k \parallel_{2}$;
    \Until{($f(x_k)>f(x_{k-1})$)}
  \end{algorithmic}
\end{algorithm}