\chapter{Flow entry verification and Fake link detection}
This work presents the detection method for the scenario in which a switch is compromised, and focuses on the problem that a compromised switch will bring. The possibilities of how attacks happen has already been discussed in \ref{SDN security}. As a defender, we will focus on detection methods of certain scenarios. There are two parts in our work. We will define the threat model both parts share, and both parts will be explained along with their attack scenarios and detection algorithm separately.

\section{Threat model and Attack scenario}
The attacks take place in a SDN network. The following assumptions is used as threat model:
\begin{enumerate}
\item
Only one controller is used. No cooperation for attack will happen between multiple compromised switches.
\item
OpenFlow version 1.3 is used as Southbound protocol.
\item
The switches is able to access the Internet. 
\item
Only one OpenFlow switch is compromised. No cooperation for attack will happen between multiple entities inside SDN network.
\item
Other parts of the network such as controller, other switches and hosts function normally. Any potential flaw is unintentional and is out of our scope.
\item
An attacker cannot totally change the way of switch processing or core mechanism. He can only perform attack by manipulating some elements.
\item
Initially, the network is all clean, nothing has been compromised. The attacks take place some time after the whole network is established.

Assume an attacker is able to add, remove, or modify the entries in the flow tables of the compromised
switch without notifying the controller. Packets might be forwarded to the undesired destination, and the proposed method tries to detect this behavior with high efficiency. In this method, only output action is considered, other actions such as drop packets, set field, change TTL etc. will be ignored. 

It is quite reasonable that more than one switches are the made by the same manufacturer or have the same software version, which might result in multiple switches being compromised. However, cooperation between multiple compromised switches makes the scenario a lot more complicate. Take our own method as an example, suppose there are two compromised switches, CS1 and CS2, that are neighbor to each other, and both of them contain an entry in the same aggregation group. When CS1 receives a detection packet and forwarded to other place maliciously, it sends a copy to CS2, and the rest of the detection process will continue without raising any suspicion. In order to simplify the case as a starting point for detection method developing, we assume only one switch inside the network is compromised.

\end{enumerate}

\section{Flow entry verification}
In the first part of our work, we propose a method that is able to detect if the flow entries work as expected. The method is inspired by \cite{CKGL15}. There are mainly two enhancement in our work: First, our method reduce the needed packet number and therefore increase the efficiency significantly. Second, the additional flow entries we need to install is less than the original method, resulting in lower cost for setting up and cleaning up. 

\subsection{Detection method}
\label{Detection_method}
The main idea of the method is to assemble a packet that will go through a series of switches by matching the match fields in the flow entries of those switches. Then the packet will be sent into the network, and should be sent back to the controller if nothing goes wrong. In order to achieve such goal, we take advantage of network-wise visibility provided by the controller. The flowchart of the flow entry detection process in the controller is shown as Figure~\ref{flow_entry_detection_flowchart}. 

\begin{figure}[H]
\begin{center} 
\includegraphics[width=1\textwidth]{figures/flow_entry_detection_flowchart.png}
\end{center}
\caption{The flowchart of flow entry detection process.}
\label{flow_entry_detection_flowchart}
\end{figure}

First, we have to define the \textit{aggregated groups}. An aggregated group consists of one or more than one flow entries existing in the switches. Each of those flow entry have output action pointing to the next OpenFlow switch which contains a flow entry that is also in the same aggregated group. The flow entries in the same aggregated group must satisfy either of the two conditions, we will name them \textit{aggregation condition} for later usage: 
\begin{enumerate}
\item
There is at least one other flow entry that has exactly the same match field and same value in a different switch.
\item
There is no other flow entry with the same match field.
\item
Entries in the same group must not have forward action to a switch that cause cycle.
\end{enumerate}

With the complete view of network provided by controller and aggregation condition prepared, one is able to construct a special packet that will be sent from the first flow entry all the way down to the last flow entry in the same aggregated group, and finally come back to the controller, indicating that all the flow entries inside this aggregate group work as expected. 

Figure~\ref{aggregated_group} illustrates an aggregated group and the content of a constructed packet. The flow entries connected by arrows belong to the same group. After determining an aggregated group, the controller constructs a packet according to the match fields of flow entries inside the aggregated group. With the aggregation condition, it will match every flow entry inside the aggregated group. In the example figure, we have a controller, three switches, which are S1,S2 and S3, and a packet waiting to be constructed. In S1, there is a flow entry that contains match field eth\_dst, match value A and output action to S2. In S2, the flow entry has match field ipv4\_src, match value B and output action to S3. Initially in S3, there is no flow entry that matches the aggregation condition of this aggregated group, so we use it as the ending node and set a flow entry with arbitrary match field (in the example, arp\_op is used) and value C in order to notify the controller. According to these match fields, the constructed packet will contain eth\_dst as A, ipv4\_src as B and arp\_op as C. Then the packet is sent to S1, and will match to the flow entry and be sent to S2. After this, the packet will match the second flow entry in the aggregated group and be sent to S3. Finally, when it reaches the last flow entry made by us, it will be sent back to the controller, and the processing of this aggregated group is done. 


\begin{figure}[H]
\begin{center}
\includegraphics[width=1\textwidth]{figures/aggregated_group.png}
\end{center}
\caption{An aggregated group and constructed packet.}
\label{aggregated_group}
\end{figure}

The process of generating a packet is done along with defining one aggregated group, the pseudo-code of it is as follow:

\begin {tcolorbox}[blanker,float=tbp,
grow to left by=1cm, grow to right by=1cm]
\begin{algorithm}[H]

  \caption{Packet generating process.}
  
  \begin{algorithmic}[1]
    \Require
      Information of all switches, $switches$;
      Global visited status of every flow entry, $visited$;
      An under-constructing packet that is initially empty, $packet$; 

    \Function{flow\_entry\_traversal}{switches}
      \ForAll{$switch$ in $switches$}
        \ForAll{$entry$ in $switch$}
          \State Extract $match\_field$, $match\_value$, $action$ from $entry$;
          \State $entry\_id \gets \textit{switch} + \textit{match\_field} + \textit{match\_value}$;  
          \State //xxxxxxxxxxxxxxxxxxxxxx
          \If{NOT $visited$[$entry\_id$]}
            \State $\textit{visited}[\textit{entry\_id}] \gets true$;
            \State $packet[\textit{match\_field}] \gets \textit{match\_value}$;
            \State $\textit{complete\_packet} \gets \Call{packet\_gen}{\textit{match\_field}, \textit{match\_value}, \textit{action}, \textit{packet}}$;
          \EndIf
      \EndFor
        \EndFor
    \EndFunction
    \State
    \Function{packet\_gen}{match\_field$, match\_value$, action$, packet$}      
      \State Extract $next\_switch$ from $action$;
      \ForAll {$entry$ in $next\_switch$}
        \State Extract $match\_field$, $match\_value$, $action$ from $entry$;
  \algstore{packet_generating}
  \end{algorithmic}
\end{algorithm}
\end{tcolorbox}

\begin {tcolorbox}[blanker,float=tbp,
grow to left by=1cm, grow to right by=1cm]
\begin{algorithm}[H]
  \begin{algorithmic}[1]
  \algrestore{packet_generating}
        \State $\textit{entry\_id} \gets \textit{switch} + \textit{match\_field} + \textit{match\_value}$;
        \If{NOT $visited$[$entry\_id$]}  
          \If{$packet$[$match\_field$] is set and $packet$[$match\_field$] = $match\_value$}            
            \State $\textit{visited}[\textit{entry\_id}] \gets true$;
            \State \Return \Call{packet\_gen}{$match\_field$, $match\_value$, $action$, $packet$};
          \ElsIf{$packet$[$match\_field$] is not set}
            \State $\textit{visited}[\textit{entry\_id}] \gets true$;
            \State $\textit{packet}[\textit{match\_field}] \gets \textit{match\_value}$;
            \State \Return \Call{packet\_gen}{$match\_field$, $match\_value$, $action$, $packet$};
          \EndIf
        \EndIf
      \EndFor
      \State Install new flow entry with action forwarding to controller into $next\_switch$;
      \State \Return $packet$;
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\end{tcolorbox}

When defining an aggregated group, we start with an unvisited flow entry, seek for a flow entry that matches the aggregation condition, and go to the next flow entry in other switch according to the output action recursively. Eventually, switch that does not have any entry that matches the aggregation condition for this group is reached, the aggregated group defining process ends, and a packet will be generated in correspondent to the flow entries inside the aggregated group. According to the aggregation condition, every aggregated group will be mutual exclusive. By looping through all the flow entries inside the switches, we should be able to cover all of the flow entries with multiple aggregated group. After all of the flow entries with output action is visited and belong to certain aggregated groups, and all the flow entries will be verified after sending the same number of packets with the number of aggregated groups. 

In real case, the variety of the conditions we try to aggregate can be much more complicated. A flow entry might have multiple match fields. Multiple flow table may also cause similar problem. When the action in a flow entry send the packet to next table for further processing. The packet is also matched against more than one match field. These kind of situations can still be covered by our method with some modification. 
If all the fields and values match the under-constructing packet, we process it according to first aggregation rule. Otherwise we fill the packet with all of those match fields. If any match fields is already taken with different value, it will be ignored for this turn of aggregation process and fill the match fields in another packet that has no conflict field. However, the number of flow entries aggregated in a packet is reduced, and so is the effectiveness. Another condition is the conjunction action that ties groups of individual flows with same match field and different value into ``conjunctive  flows'' and reduce the number of flow entry~\ref{OVS_OFCTL}. It can also be dealt in a specific way. However, the main purpose of our method is to demonstrate the result of flow entry aggregation. We will only use the most simple condition, which is a match field that has one value.

\section{Fake link detection}

-----
When a switch is compromised, an attacker is surely able to drop LLDP and causes DOS. However, it is very noticeable. We will focus on the MITM types of attack
-----
\subsection{Attack scenario}
\subsection{Detection method}


-----------------------------------------------------------
control-channel hijacking \cite{AAS14}. 

Compromised switches not only have the same capabilities as the malicious hosts, but they are also capable of performing more dynamic and severe attacks.
First, a compromised switch can be used for traffic eavesdropping. Both data and control traffic passing through the compromised switch can be replicated and sent to the attacker for further processing. Furthermore, the attacker can interfere with the control traffic passing through the compromised
switches to perform man-in-the-middle attacks [8]. By doing so, the
attacker can act as the controller to some target switches. The attacker can
also spoof control messages to the controller on behalf of the target

Below is our attack scenario assumption: 
- The control channel is properly protected with TLS protocol, meaning
that it provides confidentiality for the control traffic as well as mutual
authentication between the controller and switches.

Packet pair

- The dispersion in normal vs attack scenario, regardless of congestion

----
If this is not the case, further narrow down process is needed to find the location of the compromised switch XXXXXXXXXXXXXXXXXXXXXXX.
----

Time and space complexity


Packet forwarded to non-existent ports are just dropped
