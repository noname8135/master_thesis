\chapter{Flow entry verification and Fake link detection}
This work focuses on the problem that a compromised switch will bring and presents the methods to detect such a switch. This work involves two parts: \textit{flow entry verification} and \textit{fake link detection}. We will define the threat model that both parts share, and explain them along with their attack scenarios and detection algorithms.

\section{Threat model and Attack scenario}
In this work, we assume the following scenario of compromising a switch in the threat model:
\begin{enumerate}
\item
One controller is used, and only one OpenFlow switch is compromised. No cooperation among multiple compromised switches for attacks will happen.
\item
The switches are able to access the Internet. 
\item
Other parts of the network such as the controller, other switches and hosts function normally. Any potential flaw is unintentional and is out of the scope of this work.
\item
An attacker cannot totally change the way of switch processing or core mechanism, but only perform the attack by modifying flow entries or forge LLDP to cause fake links.
\item
Initially, the network is all clean, and nothing is compromised. The attacks take place some time after the whole network is established.
\end{enumerate}

The attack scenarios beyond the assumptions such as multiple compromised switches, as well as possible circumvention, will be discussed in Section~\ref{Further_discussion}.

\section{Flow entry verification}
In the first part of this work, we propose a method to detect if the flow entries of a switch work as expected. The method is inspired by \cite{CKGL15}. The method in this work has two main enhancements. First, it reduces the number of detection packets required, and therefore increases the efficiency significantly. Second, the additional flow entries we need to install is less than the previous method, resulting in lower cost for setting up and cleaning up. 

\subsection{Detection method}
\label{Detection_method}
The main idea of the method is to assemble a packet that will go through a sequence of switches by matching the match fields in the flow entries of these switches. Then the packet will be sent into the network, go through the switches, and should be sent back to the controller finally if nothing goes wrong. Therefore, a detection packet can check whether the matched flow entries on these switches work as expected or not. For this purpose, we need to find the sequence of switches that the detection packet should pass through, find the flow entry on each switch with which the packet will be matched, and set the fields in the packet so that it will pass through the switches in order. Because the controller has the network-wise visibility and the policy of all the flow entries, it is able to decide the sequence of switches to be involved and the detection packet in each run of detection.

The flow chart of the flow entry detection process in the controller is shown in Figure~\ref{flow_entry_detection_flowchart}. Let $S=\{s_1,s_2,\ldots,s_n\}$ be the set of switches under the control of a controller, and $f(s_i)$, where $i=1\ldots n$, represents the flow entries on $S_i$. Let $F=\cup_{i=1}^n f(s_i)$. In the first step, we attempt to find a partition $P$ of $F$, such that each element in $P$ (i.e., a subset of $F$), namely an \textit{aggregated group}, contains exactly one selected flow entry on each switch from a non-empty subset of $S$. The flow entry on each switch is selected according to the following condition, namely the \textit{aggregation conditions}, and it should have an output action that forwards the matched packets to the next switch. In other words, each detection packet will sequentially pass through a sequence of switches whose selected flow entry makes up an aggregate group. Eventually, it will arrive at the last switch, where the last flow entry of the group locates. When the output action of last entry is executed, the detection packet will be sent to a switch that does not contain any flow entry belong to the same aggregated group. On that particular switch, we need to add an additional flow entry which sends the detection packet back to the controller in order to notify the controller that the detection process of this aggregated group is carried out as expected. 

\begin{enumerate}
\item
In the same group, the flow entries on different switches either have exactly the same match fields and values, or have no common match fields.
\item
There is no switch that has more than flow one entry selected in the same group. \sout{\red{Given that we have said ``one selected flow entry on each switch in the same group'' in the last paragraph, is the condition still needed?}}.
\item
The forged detection packets should be valid. 
\end{enumerate}

\begin{figure}[H]
\begin{center} 
\includegraphics[width=1\textwidth]{figures/flow_entry_detection_flowchart.pdf}
\end{center}
\caption{The flow chart of the flow entry detection process.}
\label{flow_entry_detection_flowchart}
\end{figure}

The aggregation conditions are defined to ensure a valid detection packet can be forged and be sent through switches. The first condition is the essential idea of the method: aggregating flow entries this way allows us to forge a packet with multiple fields that matches the entries inside the same aggregated group. The second condition is to eliminate the cycle. It is the reason for each switch in the same aggregated group to contain only one flow entry. Without this condition, for example, if there are two selected entries with same priority on a same switch, then the detection packet will be matched by only one of them. As a result, it will be forwarded to the same switch every time since it is always matched to the same flow entry and the same action set is executed, causing infinity loop. The third condition is for the dependency requirement of match field in OpenFlow. For example, it is not allowed to install a flow entry that has ipv4\_src as match field without eth\_type equals to 0x0800. Therefore, the validity of detection packets should also be check while finding aggregated groups.

One detection packet is required for each aggregated group, so minimizing the number of aggregated groups means the number of detection packets, which also means fast detection. Given the above aggregation condition, we want to \textit{look for the minimized partition of aggregated groups from $F$}. For a sequence of switches involved in an aggregated group, a detection packet will pass through these switches in order. Starting from the first switch, we try to find a flow entry that matches the requirement inside it, and it has output action to the second switch. We move on to the second switch and try to find an entry which also meets the requirement, and it has a forwarding action to the third switch, and so on. Eventually, when the last switch does not contain any flow entry that fits the requirement, a new flow entry with action forwarding to the controller will be installed on it.

Figure~\ref{aggregated_group} illustrates a realistic example with an aggregated group and the content of a constructed packet. The flow entries connected by arrows belong to the same group. The controller constructs a packet according to the match fields of flow entries inside the aggregated group. In the example figure, we have a controller, three switches, which are $s_1$,$s_2$ and $s_3$, and a packet waiting to be constructed. In $s_1$, there is a flow entry that contains match field eth\_dst=a2:b4:c6:d8:e0:f1 and output action to $s_2$. In $s_2$, the flow entry has match field \texttt{eth\_type}=0x800, \texttt{ipv4\_src}=140.123.103.123 and output action to $s_3$. The eth\_type=0x800 is the required for a valid ip match field. According to the match fields of these flow entries in the aggregated group, the forged detection packet will contain \texttt{eth\_dst} as a2:b4:c6:d8:e0:f1, \texttt{ipv4\_src} as 140.123.103.123. Initially in $s_3$, there is no flow entry that belongs to this aggregated group. So we add a flow entry with arbitrary match field that matches the detetction packet, in this example, eth\_dst=a2:b4:c6:d8:e0:f1, and action ouput to controller in order to notify the controller. Then the packet is sent to $s_1$, goes through $s_2$, $s_3$, and back to the controller. Then, detection process of this aggregated group is done.

\begin{figure}[H]
\begin{center}
\includegraphics[width=1\textwidth]{figures/aggregated_group.png}
\end{center}
\caption{An aggregated group and constructed packet.}
\label{aggregated_group}
\end{figure}

The process of generating a packet is done along with defining one aggregated group, the pseudo-code of it is as follow:

\begin {tcolorbox}[blanker,float=tbp,
grow to left by=1cm, grow to right by=1cm]
\begin{algorithm}[H]

  \caption{Packet generating process.}
  \begin{algorithmic}[1]
    \Require
      Information of all switches, $switches$;
      Global visited status of every flow entry, $visited\_entry$;  
      Visited status of every switch in an aggregated group, $visited\_switch$;
      An under-constructing packet that is initially empty, $packet$; 

    \Function{flow\_entry\_traversal}{switches}
      \ForAll{$switch$ in $switches$}
        \ForAll{$entry$ in $switch$}
          \State Extract $match\_field$, $match\_value$, $action$, $cookie$ from $entry$;
          \State $entry\_id \gets \textit{cookie}$; //use cookie as entry identifier
          \State 
          \State Extract $next\_switch$ from $action$;
          \If{NOT $visited\_entry$[$entry\_id$] and NOT $visited\_switch$[$next\_switch$]}
            %\State $\textit{visited\_switch}[\textit{switch}] \gets true$;
            \State $\textit{visited\_entry}[\textit{entry\_id}] \gets true$;
            \State $packet[\textit{match\_field}] \gets \textit{match\_value}$;
            \State $\textit{complete\_packet} \gets \Call{packet\_gen}{\textit{match\_field}, \textit{match\_value}, \textit{action}, \textit{packet}}$;
            \State Send $\textit{complete\_packet}$ with PACKET\_OUT;
          \EndIf
      \EndFor
        \EndFor
    \EndFunction
    \State
    \Function{packet\_gen}{match\_field$, match\_value$, action$, packet$}      
      \ForAll {$entry$ in $next\_switch$}
        \State Extract $match\_field$, $match\_value$, $action$, $cookie$ from $entry$;
        \State Extract $next\_switch$ from $action$; 
  \algstore{packet_generating}
  \end{algorithmic}
\end{algorithm}
\end{tcolorbox}

\begin {tcolorbox}[blanker,float=tbp,
grow to left by=1cm, grow to right by=1cm]
\begin{algorithm}[H]
  \begin{algorithmic}[1]
  \algrestore{packet_generating}
        \State $\textit{entry\_id} \gets \textit{cookie}$;
        \If{NOT $visited\_entry$[$entry\_id$] and NOT $visited\_switch$[$next\_switch$]}  
          \State $\textit{visited\_entry}[\textit{entry\_id}] \gets true$;
          \State $\textit{visited\_switch}[\textit{next\_switch}] \gets true$;
          \If{$packet$[$match\_field$] is set and $packet$[$match\_field$] = $match\_value$}            
            \State \Return \Call{packet\_gen}{$match\_field$, $match\_value$, $action$, $packet$};
          \ElsIf{$packet$[$match\_field$] is not set}
            \State $\textit{packet}[\textit{match\_field}] \gets \textit{match\_value}$;
            \State \Return \Call{packet\_gen}{$match\_field$, $match\_value$, $action$, $packet$};
          \EndIf
        \EndIf
      \EndFor
      \State Install new flow entry with action forwarding to controller into $next\_switch$;
      \State $\textit{visited\_switch} \gets EMPTY$;
      \State \Return $packet$;
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\end{tcolorbox}

In order to optimize the number of necessary detection packets, the whole network should be covered with the minimum number of aggregated groups. By taking switches as vertices and forwarding actions as edges, it forms a complex graph problem. It is more complex than the longest path problem \cite{DMR97,RU04}, which is also NP-complete in time complexity and hard to find a approximation algorithm. Inspired by Euler Path, we calculate the number that every vertex is destination of some edges, and use it as visiting priority as an approximation method. The reason behind the thought is that, the vertex which is treated as the destination the least time should be used as start point in order to reduce the number of necessary groups.

The cookie is used to identify every unique entry in different switches. When defining an aggregated group, we start with an unvisited flow entry that currently is treated as destination the least time, seek for an unvisited flow entry that matches the aggregation condition, and go to the next flow entry in other switch according to the output action recursively. Eventually, switch that does not have any entry that matches the aggregation condition for this group is reached, the aggregated group defining process ends, and a packet will be generated in correspondent to the flow entries inside the aggregated group. According to the aggregation condition, every aggregated group will be mutual exclusive. By going through through all the flow entries inside the switches, we should be able to cover all of the flow entries with multiple aggregated group. After all of the flow entries with output action is visited and belong to certain aggregated groups, and all the flow entries will be verified after sending the same number of packets with the number of aggregated groups. 

\subsection{Further discussion of attack scenario and our method}
\label{Further_discussion}

In real case, the variety of the conditions aggregation may be much more complicated. A flow entry might have multiple match fields. Multiple flow table may also cause similar problem. When the action in a flow entry send the packet to next table for further processing. The packet is also matched against more than one match field indirectly. These kind of situations can still be covered by our method with some modification. If all the fields and values match the under-constructing packet, we process it according to first aggregation rule. Otherwise we fill the packet with all of those match fields. If any match field is already taken with different value, it will be ignored for this turn of aggregation process and fill the match fields in another packet that has no conflict field. However, the number of flow entries aggregated in a packet is reduced, and so is the effectiveness. Another condition is the conjunction action that ties groups of individual flows with same match field and different value into ``conjunctive flows'' and reduce the number of flow entry \cite{OVS_OFCTL}. Since it is a similar problem, it should be able to be dealt if one manage to resolve the complex conjunctive conditions. However, the main purpose of our method is to show the effectiveness of flow entry aggregation method. We will demonstrate with the most simple condition, which is that every entry has only one matching field and use only one flow table.

It is certainly possible that more than one switch are made by the same manufacturer or have the same software version in the same network, so multiple switches share the same vulnerabilities and may be compromised simultaneously. However, cooperation between multiple compromised switches complicates the scenario significantly. Taking our own method as an example, suppose there are two compromised switches, CS1 and CS2, which are neighbors to each other, and both contain an entry in the same aggregated group. When CS1 receives the detection packet and forwards it to other place maliciously, it sends one copy of detection packet to CS2, the other copy back to the controller, and the rest of the detection process will continue without raising any suspicion\sout{\red{Since the controller does not receive the detection packet, is it possible to raise a suspicion here?}}. In order to simplify the case as a starting point for developing the detection method, we assume only one switch inside the network is compromised.

Suppose an attacker is able to add, remove, or modify the entries in the flow tables of a compromised
switch without notifying the controller, so packets may be forwarded to an undesired destination. The proposed method is intended to detect this behavior with high efficiency. In this method, only output action of packets is considered. Other actions such as dropping packets, setting field, changing TTL will be ignored \sout{\red{Cann't they (e.g., dropping packets) be detected?}}. Although there are reasonable methods to deal with these actions, for example, to detect packet dropping, we can add timeout checking function, such detection function is irrelevant to our main method and is not implemented in our work.

In this detection method, there is another important consideration: the controller must maintain unpolluted information of all flow entries. It is not reliable for a controller to obtain flow entry information by querying switches because a switch may be malicious and forge a fake response that gives false information about the flow entries. That is the reason for the last statement of attack model. It is also possible to initiate OpenFlow message from a switch, such as adding a new flow entry, resulting in adding a malicious entry without raising any alarm. However, it also means that it expose the malicious behavior to controller and is quite noticeable.

\section{Fake link detection}

-----
When a switch is compromised, an attacker is surely able to drop LLDP and causes DOS. However, it is very noticeable. We will focus on the MITM types of attack
-----
\subsection{Attack scenario}
\subsection{Detection method}


-----------------------------------------------------------

Below is our attack scenario assumption: 
- The control channel is properly protected with TLS protocol, meaning
that it provides confidentiality for the control traffic as well as mutual
authentication between the controller and switches.

Packet pair

- The dispersion in normal vs attack scenario, regardless of congestion

----
If this is not the case, further narrow down process is needed to find the location of the compromised switch XXXXXXXXXXXXXXXXXXXXXXX.
----

Time and space complexity


Packet forwarded to non-existent ports are just dropped
